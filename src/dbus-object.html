
<dom-module id="dbus-object">
	<template>
	</template>
	<script>
		class DBusObject extends Polymer.Element {
			static get is () { return 'dbus-object' }

			static get properties () {
				return {
					selector: { observer: 'updateState' },
					service: { type: String, observer: 'updateState' },
					objectPath: { type: String, observer: 'updateState' },
					object: { type: Object, notify: true },
					partialObject: { type: Object },
					signals: { type: Array, observer: 'updateState' },
					watchChanges: { type: Boolean, value: false },
					debug: { type: Boolean },
				}
			}

			constructor () {
				super()

				this._signals = null
			}

			////////////////////////////////////////////////
			////////////// dbus-object API /////////////////
			////////////////////////////////////////////////

			get (iface, propName) {
				if (this.object == null) {
					return
				}

				this.object.get(iface, propName)
			}

			getAll (iface) {
				if (this.object == null) {
					return
				}

				this.object.getAll(iface)
			}

			call (method, data, callback) {
				if (this.object == null) {
					return
				}

				this.object.call (method, data, callback)
			}

			watchProperties () {
				if (this.object == null) {
					return
				}
				
				this.object.watchProperties (this)
			}

			unwatchProperties () {
				if (this.object == null) {
					return
				}

				this.object.unwatchProperties (this)
			}

			watchSignal (signal, callback) {
				if (this.object == null) {
					return 
				}

				this._signals.push({signal, callback})

				this.object.on(signal, callback)
				this.object.onSignal(signal, callback)
			}

			unwatchSignal (signal, callback) {
				if (this.object == null) {
					return
				}

				//remove signal from signals list
				this._signals = this._signals.filter (s => s.signal !== signal && s.callback !== callback)

				this.object.removeListener (signal, callback)
				this.object.removeSignalListener(signal, callback)
			}

			////////////////////////////////////////////
			/////////// Internal methods ///////////////
			////////////////////////////////////////////
			
			updateState () {
				//avoid updating state multiple times when multiple properties are changed in the same function
				if (this._updateRequest != null) return
				this._updateRequest = setTimeout (() => {
					this._updateRequest = null
					this._doUpdateState ()
				})
			}

			_doUpdateState () {
				// remove old callbacks
				if (this.object != null) {
					this.unwatchProperties ()
					this._unregisterSignals ()
					this.object.removeListener ('properties-changed', this._propertiesChangedCallback)
					this.object = null
				}

				if (this.selector == null 
					|| (Array.isArray(this.selector) && this.selector.length === 0) 
					|| this.service == null 
					|| this.objectPath == null) {
					return
				}

				let obj = d1(this.selector).dbusObject(this.service, this.objectPath, this.partialObject)

				if (obj.length !== 1) {
					this.dispatchEvent(new CustomEvent('error', { detail: 'dbus-object : unsupported object count ('+obj.lengh+')' }))
				}

				this.object = obj[0]

				this._registerSignals ()

				this._propertiesChangedCallback = (...args) => this._onPropertiesChanged(...args)
				this.object.on('properties-changed', this._propertiesChangedCallback)

				
				if (this.watchChanges) {
					this.watchProperties ()
				}
			}

			_registerSignals () {
				this._signals = []

				//if signals are defined, subscribe to them
				if (!Array.isArray(this.signals)) { 
					return
				}
				
				//save signals and associated callback for later unsubscription
				this.signals.forEach (s => {
					if (typeof s[0] !== 'string' || typeof s[1] !== 'function'){
						console.warn (`Ignoring malformed signal ${s[0]} !`)	
						return
					}
					this.watchSignal (s[0], s[1])
				})

			}

			_unregisterSignals () {
				if (!Array.isArray(this._signals)) {
					return
				}

				this._signals.forEach (s => this.unwatchSignal (s.signal, s.callback))
				this._signals = null
			}

			_onPropertiesChanged (iface, changedProperties, invalidatedProperties) {
				for (let propName in changedProperties) {
					this.notifyPath(`object.${iface}.${propName}`)
				}

				invalidatedProperties.forEach(propName => {
					this.notifyPath(`object.${iface}.${propName}`)
				})
			}
		}

		customElements.define(DBusObject.is, DBusObject)
	</script>
</dom-module>
