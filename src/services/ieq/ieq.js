/* maya-client
 * Copyright (c) 2014, Partnering Robotics, All rights reserved.
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; version
 *	3.0 of the License. This library is distributed in the hope
 * that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU Lesser General Public License for more details.
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.
 */

/**
   Todo :
   check err for each data
   improve API : getData(sensorName, dataConfig)
   return adapted vector for display with D3 to reduce code in IHM ?
   updateData(sensorName, dataConfig)
   set and get for the different dataConfig params

*/

DiyaSelector = require('../../DiyaSelector').DiyaSelector;
var util = require('util');


var Message = require('../message');

/**
 *	callback : function called after model updated
 * */
function IEQ(selector){
	var that = this;
	this.selector = selector;
	this.dataModel={};


	/*** structure of data config ***
		 criteria :
		 time:
		 beg: {[null],time} (/ means most recent) // stored a UTC in ms (num)
		 end: {[null], time} (/ means most oldest) // stored as UTC in ms (num)
		 robot: {ArrayOf ID or ["all"]}
		 place: {ArrayOf ID or ["all"]}
		 operator: {[last], max, moy, sd} -( maybe moy should be default
		 ...

		 sensors : {[null] or ArrayOf SensorName}

		 sampling: {[null] or int}
	*/
	this.dataConfig = {
		criteria: {
			time: {
				beg: null,
				end: null
			},
			robot: null,
			place: null
		},
		operator: 'last',
		sensors: null,
		sampling: null //sampling
	};
	//	  this.callback = callback || function(res){}; /* callback, usually after getModel */

	return this;


	// this.selector.request({
	// service: "ieq",
	// func: "DataRequest",
	// data: {
	//	   type:"msgInit",
	//	   dataConfig: {
	//	operator: 'last',
	//	sensors: {},
	//	sampling: 1 //sampling
	//	   }
	// }
	// }, function(dnId, err, data){
	// //console.log("init: data : "+JSON.stringify(data));
	//
	// // TODO : add init loop process
	//
	// if(data.header.error) {
	//	   // TODO : check/use err status and adapt behavior accordingly
	//	   console.log("Data request failed ("+data.header.error.st+"): "+data.header.error.msg);
	//	   return;
	// }
	//
	// that._getDataModelFromRecv(data);
	// console.log(JSON.stringify(that.dataModel));
	// /** TO BE REMOVED ? */
	// /*that.updateQualityIndex();
	// that._updateLevels(that.dataModel);
	// that.callback(that.dataModel);*/
	//
	// that.timedRequest = function() {
	//	   var now = new Date();
	//	   var beg_time = new Date(now - 5*24*60*60*1000);
	//	   console.log("now "+now+" / beg time "+beg_time);
	//
	//	   that.setDataTime(beg_time,now);
	//	   that.setDataSampling(null);
	//	   /* that.dataConfig.criteria.time = {
	//	beg: beg_time,
	//	end: now
	//	   };*/
	//	   this.selector.request({
	//	service: "ieq",
	//	func: "DataRequest",
	//	data: {
	//		type:"splReq",
	//		dataConfig: that.dataConfig
	//	}
	//	   }, function(dnId, err, data){
	//	console.log(JSON.stringify(data));
	//	if(data.header.error) {
	//		// TODO : check/use err status and adapt behavior accordingly
	//		console.log("timedRequest:\n"+JSON.stringify(data.header.dataConfig));
	//		console.log("Data request failed ("+data.header.error.st+"): "+data.header.error.msg);
	//		return;
	//	}
	//	// console.log(JSON.stringify(that.dataModel));
	//	that._getDataModelFromRecv(data);
	//	// console.log(JSON.stringify(that.dataModel));
	//
	//	that.updateQualityIndex();
	//	that._updateLevels(that.dataModel);
	//	that.callback(that.dataModel);
	//	   });
	//	   setTimeout(that.timedRequest,3000);
	// };
	// //setTimeout(that.timedRequest(),3000);
	//
	// /*
	//	 this.selector.subscribe({
	//	service: "ieq",
	//	func: "SubscribeIeq"
	//	}, function(res) {
	//	that._getDataModelFromRecv(res.data);
	//	that._updateLevels(that.dataModel);
	//	that.callback(that.dataModel);
	//	});
	// */
	// });
	// return this;
};
/**
 * Get dataModel :
 * {
 *	time: [FLOAT, ...],
 *	"senseurXX": {
 *			data:[FLOAT, ...],
 *			qualityIndex:[FLOAT, ...],
 *			range: [FLOAT, FLOAT],
 *			unit: string,
 *		label: string
 *		},
 *	 ... ("senseursYY")
 * }
 */
IEQ.prototype.getDataModel = function(){
	return this.dataModel;
};
IEQ.prototype.getDataRange = function(){
	return this.dataModel.range;
};

IEQ.prototype.updateQualityIndex = function(){
	var that=this;
	var dm = this.dataModel;

	for(var d in dm) {
		if(d=='time' || !dm[d].data) continue;

		/* default value for robotId and placeId */
		if(d=='robotId' || d=='placeId') {
			dm[d].qualityIndex=[];
			dm[d].data.forEach(function(v,i) {
				dm[d].qualityIndex[i] = 1;
			});
			continue;
		}
		dm[d].qualityIndex = dm[d].data.map(function(dd) {
			if(dd>=dm[d].qualityConfig.confortRange[0] && dd<=dm[d].qualityConfig.confortRange[1])
				return 1.0;
			else
				return 0.0;
		});
	}
};


IEQ.prototype.getDataconfortRange = function(){
	return this.dataModel.confortRange;
};
/**
 * @param {Object} dataConfig config for data request
 * if dataConfig is define : set and return this
 *	 @return {IEQ} this 
 * else
 *	 @return {Object} current dataConfig
 */
IEQ.prototype.DataConfig = function(newDataConfig){
	if(newDataConfig) {
		this.dataConfig=newDataConfig;
		return this;
	}
	else
		return this.dataConfig;
};
/**
 * TO BE IMPLEMENTED : operator management in DN-IEQ
 * @param  {String}	 newOperator : {[last], max, moy, sd}
 * @return {IEQ} this - chainable
 * Set operator criteria.
 * Depends on newOperator
 *	@param {String} newOperator 
 *	@return this 
 * Get operator criteria.
 *	@return {String} operator
 */
IEQ.prototype.DataOperator = function(newOperator){
	if(newOperator) {
		this.dataConfig.operator = newOperator;
		return this;
	}
	else 
		return this.dataConfig.operator;
};
/** 
 * Depends on numSamples
 * @param {int} number of samples in dataModel
 * if defined : set number of samples
 *	@return {IEQ} this
 * else
 *	@return {int} number of samples
 **/
IEQ.prototype.DataSampling = function(numSamples){
	if(numSamples) {
		this.dataConfig.sampling = numSamples;
		return this;
	}
	else
		return this.dataConfig.sampling;				
};
/**
 * Set or get data time criteria beg and end.
 * If param defined
 *	@param {Date} newTimeBeg // may be null
 *	@param {Date} newTimeEnd // may be null
 *	@return {IEQ} this
 * If no param defined:
 *	@return {Object} Time object: fields beg and end.
 */
IEQ.prototype.DataTime = function(newTimeBeg,newTimeEnd){
	if(newTimeBeg || newTimeEnd) {
		this.dataConfig.criteria.time.beg = newTimeBeg.getTime();
		this.dataConfig.criteria.time.end = newTimeEnd.getTime();
		return this;
	}
	else
		return {
			beg: new Date(this.dataConfig.criteria.time.beg),
			end: new Date(this.dataConfig.criteria.time.end)};
};
/**
 * Depends on robotIds
 * Set robot criteria.
 *	@param {Array[Int]} robotIds list of robot Ids
 * Get robot criteria.
 *	@return {Array[Int]} list of robot Ids
 */
IEQ.prototype.DataRobotIds = function(robotIds){
	if(robotIds) {
		this.dataConfig.criteria.robot = robotIds;
		return this;
	}
	else
		return this.dataConfig.criteria.robot;
};
/**
 * Depends on placeIds
 * Set place criteria.
 *	@param {Array[Int]} placeIds list of place Ids
 * Get place criteria.
 *	@return {Array[Int]} list of place Ids
 */
IEQ.prototype.DataPlaceIds = function(placeIds){
	if(placeIds) {
		this.dataConfig.criteria.placeId = placeIds;
		return this;
	}
	else
		return this.dataConfig.criteria.place;				
};
/**
 * Get data by sensor name.
 *	@param {Array[String]} sensorName list of sensors
 */
IEQ.prototype.getDataByName = function(sensorNames){
	var data=[];
	data.push(this.dataModel['time']);
	for(var n in sensorNames) {
		data.push(this.dataModel[sensorNames[n]]);
	}
	return data;
};
/**
 * Update data given dataConfig.
 * @param {func} callback : called after update
 * TODO USE PROMISE
 */
IEQ.prototype.updateData = function(callback, dataConfig){
	var that=this;
	if(dataConfig)
		this.DataConfig(dataConfig);
//	console.log("Request: "+JSON.stringify(dataConfig));
	this.selector.request({
		service: "ieq",
		func: "DataRequest",
		data: {
			type:"splReq",
			dataConfig: that.dataConfig
		}
	}, function(dnId, err, data){
		console.log("err "+JSON.stringify(err));
		if(err) {
			console.log("Recv err: "+err);
			return;
		}
		if(data.header.error) {
			// TODO : check/use err status and adapt behavior accordingly
			console.log("UpdateData:\n"+JSON.stringify(data.header.dataConfig));
			console.log("Data request failed ("+data.header.error.st+"): "+data.header.error.msg);
			return;
		}
		//console.log(JSON.stringify(that.dataModel));
		that._getDataModelFromRecv(data);
		
		console.log(that.getDataModel());
		
		that.updateQualityIndex();
		//that._updateLevels(that.dataModel);

		callback = callback.bind(that); // bind callback with IEQ
		callback(that.getDataModel()); // callback func
	});
	/** TODO USE PROMISE ? */
};

IEQ.prototype._isDataModelWithNaN = function() {
	var dataModelNaN=false;
	var sensorNan;
	for(var n in this.dataModel) {
		sensorNan = this.dataModel[n].data.reduce(function(nanPres,d) {
			return nanPres && isNaN(d);
		},false);
		dataModelNaN = dataModelNaN && sensorNan;
		console.log(n+" with nan : "+sensorNan+" ("+dataModelNaN+") / "+this.dataModel[n].data.length);
	} 
};


IEQ.prototype._updateConfinementLevelDEPRECATED = function(model){
	/** check if co2 and voct are available ? */
	var co2 = model['CO2'].data[model['CO2'].data.length - 1];
	var voct = model['VOCt'].data[model['VOCt'].data.length - 1];
	var confinement = Math.max(co2, voct);

	if(confinement < 800){
		return 3;
	}
	if(confinement < 1600){
		return 2;
	}
	if(confinement < 2400){
		return 1;
	}
	if(confinement < 3000){
		return 0;
	}
	/* default */
	return 0;
};

IEQ.prototype._updateAirQualityLevelDEPRECATED = function(confinement, model){
	var fineDustQualityIndex = model['Fine Dust'].qualityIndex[model['Fine Dust'].qualityIndex.length-1];
	var ozoneQualityIndex = model['Ozone'].qualityIndex[model['Ozone'].qualityIndex.length-1];

	var qualityIndex = fineDustQualityIndex + ozoneQualityIndex;
	if(qualityIndex < 2) return confinement - 1;
	else return confinement;
};

IEQ.prototype._updateEnvQualityLevelDEPRECATED = function(airQuality, model){
	var humidityQualityIndex = model['Humidity'].qualityIndex[model['Humidity'].qualityIndex.length-1];
	var temperatureQualityIndex = model['Temperature'].qualityIndex[model['Temperature'].qualityIndex.length-1];

	var qualityIndex = humidityQualityIndex + temperatureQualityIndex;
	if(qualityIndex < 2) return airQuality - 1;
	else return airQuality;
};

IEQ.prototype._updateLevelsDEPRECATED = function(model){
	this.confinement = this._updateConfinementLevel(model);
	this.airQuality = this._updateAirQualityLevel(this.confinement, model);
	this.envQuality = this._updateEnvQualityLevel(this.airQuality, model);
};

IEQ.prototype.getConfinementLevel = function(){
	return this.confinement;
};

IEQ.prototype.getAirQualityLevel = function(){
	return this.airQuality;
};

IEQ.prototype.getEnvQualityLevel = function(){
	return this.envQuality;
};


var checkQualityDEPRECATED = function(data, qualityConfig){
	var quality;
	if(data && qualityConfig) {
		if(data>qualityConfig.confortRange[1] || data<qualityConfig.confortRange[0])
			quality=0;
		else
			quality=1.0;
		return quality;
	}
	return 1.0;
};

/**
 * Update internal model with received data
 * @param  {Object} data data received from DiyaNode by websocket
 * @return {[type]}		[description]
 */
IEQ.prototype._getDataModelFromRecv = function(data){
	var dataModel=this.dataModel;
	/*\
	  |*|
	  |*|  utilitaires de manipulations de chaînes base 64 / binaires / UTF-8
	  |*|
	  |*|  https://developer.mozilla.org/fr/docs/Décoder_encoder_en_base64
	  |*|
	  \*/
	/** Decoder un tableau d'octets depuis une chaîne en base64 */
	var b64ToUint6 = function(nChr) {
		return nChr > 64 && nChr < 91 ?
			nChr - 65
			: nChr > 96 && nChr < 123 ?
			nChr - 71
			: nChr > 47 && nChr < 58 ?
			nChr + 4
			: nChr === 43 ?
			62
			: nChr === 47 ?
			63
			:	0;
	};
	/**
	 * Decode base64 string to UInt8Array
	 * @param  {String} sBase64		base64 coded string
	 * @param  {int} nBlocksSize size of blocks of bytes to be read. Output byteArray length will be a multiple of this value.
	 * @return {Uint8Array}				tab of decoded bytes
	 */
	var base64DecToArr = function(sBase64, nBlocksSize) {
		var
		sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""), nInLen = sB64Enc.length,
		nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2,
		buffer = new ArrayBuffer(nOutLen), taBytes = new Uint8Array(buffer);

		for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
			nMod4 = nInIdx & 3; /* n mod 4 */
			nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
			if (nMod4 === 3 || nInLen - nInIdx === 1) {
				for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
					taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
				}
				nUint24 = 0;
			}
		}
		// console.log("u8int : "+JSON.stringify(taBytes));
		return buffer;
	};

	var arrayFromBuffer = function(data) {
		/* decode data to Float32Array*/
		var buf = base64DecToArr(data.vals, data.byteCoding);
		var fArray=null;
		if(data.byteCoding===4)
			fArray = new Float32Array(buf);
		else if (data.byteCoding===8)
			fArray = new Float64Array(buf);

		if(data.size != fArray.length) console.log("Mismatch of size "+data.size+" vs "+fArray.length);
		var tab = new Array(data.size);
		/* update nb of samples stored */
		for(var i in fArray) {
			tab[parseInt(i)]=fArray[i]; /* keep first val - name of column */
		}
		return tab;
	};


	if(data && data.header) {
		// if(!data.header.sampling) data.header.sampling=1;
		/** case 1 : 1 value received added to dataModel - deprecated ? */

/*		if(data.header.sampling==1) {
			if(data.header.timeEnd) {
				if(!dataModel.time) dataModel.time=[];
				dataModel.time.push(data.header.timeEnd);
				if(dataModel.time.length > this.sampling) {
					dataModel.time = dataModel.time.slice(dataModel.time.length - this.sampling);
				}
			}
			for (var n in data) {
				if(n != "header" && n != "time") {
					//console.log(JSON.stringify(data[n]));
					if(!dataModel[n]) {
						dataModel[n]={};
						dataModel[n].data=[];
					}

					// update data range *
					dataModel[n].range=data[n].range;
					// update data label *
					dataModel[n].label=data[n].label;
					// update data unit *
					dataModel[n].unit=data[n].unit;
					// update data confortRange *
					dataModel[n].qualityConfig={confortRange: data[n].confortRange};

					if(data[n].data.length > 0) {
						/* decode data to Float32Array*
						var buf = base64DecToArr(data[n].data, data[n].byteCoding);
						// console.log(JSON.stringify(buf));
						var fArray=null;
						if(data[n].byteCoding===4)
							fArray = new Float32Array(buf);
						else if (data[n].byteCoding===8)
							fArray = new Float64Array(buf);

						if(data[n].size != fArray.length) console.log("Mismatch of size "+data[n].size+" vs "+fArray.length);
						if(data[n].size != 1) console.log("Expected 1 value received :"+data[n].size);

						if(!dataModel[n].data) dataModel[n].data=[];
						dataModel[n].data.push(fArray[0]);
						if(dataModel[n].data.length > this.sampling) {
							dataModel[n].data = dataModel[n].data.slice(dataModel[n].data.length - this.sampling);
						}
					}
					else {
						if(data[n].size != 0) console.log("Size mismatch received data (no data versus size="+data[n].size+")");
						dataModel[n].data = [];
					}
					this.updateQualityIndex();
					//~ console.log('mydata '+JSON.stringify(dataModel[n].data));
				}
			}
		}
		else { */
			/** case 2 : history data - many values received */
			//dataModel={}; // reset dataModel
		for (var n in data) {
			if(n != "header" && n != "err") {

				if(data[n].err && data[n].err.st>0) {
					console.log(n+" was in error: "+data[n].err.msg);
					continue;
				}

				// console.log(n);
				if(!dataModel[n]) {
					dataModel[n]={};
					dataModel[n].data={};
				}
				/* update data range */
				dataModel[n].range=data[n].range;
				/* update data label */
				dataModel[n].label=data[n].label;
				/* update data unit */
				dataModel[n].unit=data[n].unit;
				/* update data confortRange/indexRange */
				dataModel[n].qualityConfig={
					confortRange: data[n].confortRange,
					indexRange: data[n].indexRange
				};
				//					console.log("data : "+JSON.stringify(data[n]));
				if(data[n].data.vals.length > 0)
					dataModel[n].data = arrayFromBuffer(data[n].data);
				else {
					if(data[n].data.size != 0) console.log("Size mismatch received data (no data versus size="+data[n].data.size+")");
					dataModel[n].data = [];
				}
				if(data[n].time.vals.length > 0)
					dataModel[n].time = arrayFromBuffer(data[n].time);
				else {
					if(data[n].time.size != 0) console.log("Size mismatch received data (no data versus size="+data[n].time.size+")");
					dataModel[n].time = [];
				}
				if(data[n].index.vals.length > 0)
					dataModel[n].index = arrayFromBuffer(data[n].index);
				else {
					if(data[n].index.size != 0) console.log("Size mismatch received data (no data versus size="+data[n].index.size+")");
					dataModel[n].index = [];
				}
				if(data[n].robotId.vals.length > 0)
					dataModel[n].robotId = arrayFromBuffer(data[n].robotId);
				else {
					if(data[n].robotId.size != 0) console.log("Size mismatch received data (no data versus size="+data[n].robotId.size+")");
					dataModel[n].robotId = [];
				}
				if(data[n].placeId.vals.length > 0)
					dataModel[n].placeId = arrayFromBuffer(data[n].robotId);
				else {
					if(data[n].placeId.size != 0) console.log("Size mismatch received data (no data versus size="+data[n].placeId.size+")");
					dataModel[n].placeId = [];
				}
				// dataModel[n].data = Array.from(fArray);
				//console.log('mydata '+JSON.stringify(dataModel[n].data));
			}
		}
	}
	else {
		console.log("No Data to read or header is missing !");
	}
	return this.dataModel;
};

/** create IEQ service **/
DiyaSelector.prototype.IEQ = function(){
	var ieq = new IEQ(this);
	return ieq;
};
